//<auto-generated/>
//#nullable enable
#pragma warning disable

using System.Diagnostics.CodeAnalysis;
using System.Reflection;

namespace System;

internal static class TypeExts
{
  #if !NET5_0_OR_GREATER
    public static bool IsAssignableTo(this Type @this, [NotNullWhen(true)] Type? targetType) =>
        targetType?.IsAssignableFrom(@this) ?? false;

    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods | DynamicallyAccessedMemberTypes.NonPublicMethods)]
    public static MethodInfo? GetMethod(this Type @this, string name, BindingFlags bindingAttr, Type[] types) =>
        @this.GetMethod(name, bindingAttr, binder: null, types, modifiers: null);
  #endif

  #if !NET9_0_OR_GREATER
    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods | DynamicallyAccessedMemberTypes.NonPublicMethods)]
    public static MethodInfo? GetMethod(this Type @this,
        string name, int genericParameterCount, BindingFlags bindingAttr, Type[] types)
    {
      #if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER || NET5_0_OR_GREATER
        return @this.GetMethod(name, genericParameterCount, bindingAttr, null, types, null);
      #else
        // Actual implementation in RuntimeType of .NET Core 2.1+ is 10x more advanced
        var methods = @this.GetMethods(bindingAttr)
            .Where(m => m.Name == name);
        var filteredMethods = genericParameterCount == 0
            ? methods.Where(m => !m.IsGenericMethod)
            : methods.Where(m => m.IsGenericMethod && m.GetGenericArguments().Length == genericParameterCount);
        return filteredMethods
            .Single(m => m.GetParameters().Select(p => p.ParameterType).SequenceEqual(types));
      #endif
    }
  #endif
}