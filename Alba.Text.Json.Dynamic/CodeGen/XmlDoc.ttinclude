<#@   assembly name="System.Core"
#><#@ assembly name="System.Xml"
#><#@ assembly name="System.Xml.Linq"
#><#+ namespace _ {
#><#+

// ReSharper disable ConvertTypeCheckPatternToNullCheck

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Xml.Linq;
using System.Xml.XPath;
using static System.String;
using static _.Exts;

file class XmlDoc
{
    private Dictionary<string, XElement> _members = new();
    private HashSet<Type> _types = new();
    private HashSet<string> _docFiles = new();

    public XmlDoc LoadType<T>() => LoadType(typeof(T));
    public XmlDoc LoadType(Type type, string? versionOverride = null)
    {
        if (!_types.Add(type))
            return this;
        var version = type.Assembly.GetName().Version!;
        var versionPrefix = versionOverride ?? $"{version.Major}.{version.Minor}";
        return LoadModule(Path.GetFileNameWithoutExtension(type.Module.Name), versionPrefix);
    }

    public XmlDoc LoadModule(string moduleName, string versionPrefix)
    {
        var dotnetPacksDir = @"C:\Program Files\dotnet\packs";
        var packName = "Microsoft.NETCore.App.Ref";
        var versionDir = TryGetDir(Path.Combine(dotnetPacksDir, packName), $"{versionPrefix}.*");
        var refDir = TryGetDir(Path.Combine(versionDir, "ref"), $"net{versionPrefix}");
        var docFileName = moduleName + ".xml";
        if (!_docFiles.Add(docFileName))
            return this;
        using var file = File.OpenText(Path.Combine(refDir, docFileName));
        var doc = XDocument.Load(file);
        foreach (var el in doc.XPathSelectElements("/doc/members/member"))
            _members[el.Attribute("name")!.Value] = el;
        return this;

        static string TryGetDir(string dir, string mask) {
            try {
                return Directory.EnumerateDirectories(dir, mask).OrderBy(i => i).Last();
            }
            catch {
                throw new DirectoryNotFoundException($"Directory {dir}\\{mask} not found.");
            }
        }
    }

    public string FormatDoc(XElement el, int indent = 0, char indentChar = ' ')
    {
        var indentStr = new string(indentChar, indent);
        return el.Elements().Select(i => Regex.Replace($"{i}", @"\s+", " ")).Join("\n")
            .Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
            .Select(s => $"{indentStr}/// {s}")
            .Join(Environment.NewLine);
    }

    public XElement? GetDoc(TypeInfo m) => _members.GetOrDefault(GetName(m));
    public XElement? GetDoc(MethodInfo m) => _members.GetOrDefault(GetName(m));
    public XElement? GetDoc(ConstructorInfo m) => _members.GetOrDefault(GetName(m));
    public XElement? GetDoc(FieldInfo m) => _members.GetOrDefault(GetName(m));
    public XElement? GetDoc(PropertyInfo m) => _members.GetOrDefault(GetName(m));
    public XElement? GetDoc(EventInfo m) => _members.GetOrDefault(GetName(m));

    public string GetName(TypeInfo m) => "T:" + GetNameCore(m);
    public string GetName(MethodInfo m) => GetNameCore(method: m);
    public string GetName(ConstructorInfo m) => GetNameCore(ctor: m);
    public string GetName(FieldInfo m) => GetNameCore("F", m);
    public string GetName(PropertyInfo m) => GetNameCore("P", m);
    public string GetName(EventInfo m) => GetNameCore("E", m);

    string GetNameCore(Type m) =>
        m.FullName.ReReplace(@"\[.*\]", "").Replace('+', '.');

    string GetNameCore(string prefix, MemberInfo m) =>
        $"{prefix}:{GetNameCore(m.DeclaringType!)}.{m.Name}";

    string GetDocStr(Type type, bool isParam, Map map)
    {
        if (type.IsGenericParameter) {
            var methodIndex = map.Methods.GetOrDefault(type.Name, -1);
            return methodIndex != -1 ? "``" + methodIndex : "`" + map.Types[type.Name];
        }
        else if (type.HasElementType) {
            string elementTypeString = GetDocStr(type.GetElementType()!, isParam, map);
            switch (type) {
                case Type when type.IsPointer:
                    return elementTypeString + "*";
                case Type when type.IsByRef:
                    return elementTypeString + "@";
                case Type when type.IsArray:
                    int rank = type.GetArrayRank();
                    return elementTypeString + (rank > 1 ? $"[{Enumerable.Repeat("0:", rank).Join(",")}]" : "[]");
                default:
                    throw new InvalidOperationException();
            }
        }
        else {
            string prefix = type.IsNested ? GetDocStr(type.DeclaringType!, isParam, map) : type.Namespace!;
            string typeName = isParam ? Regex.Replace(type.Name, @"`\d+", "") : type.Name;
            string genericArgs = type.IsGenericType && isParam
                ? "{" + type.GetGenericArguments().Select(a => GetDocStr(a, isParam, map)).Join(",") + "}" : "";
            return $"{prefix}.{typeName}{genericArgs}";
        }
    }

    string GetNameCore(MethodInfo? method = null, ConstructorInfo? ctor = null)
    {
        if (method is { DeclaringType.IsGenericType: true })
            method = method.DeclaringType.GetGenericTypeDefinition()
                .GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic)
                .First(x => x.MetadataToken == method.MetadataToken);

        MethodBase methodBase = method ?? (MethodBase?)ctor!;
        var map = new Map(
            Types: GenericArgsToMap(methodBase.DeclaringType!.GetGenericArguments()),
            Methods: GenericArgsToMap(method?.GetGenericArguments()));
        var pars = methodBase.GetParameters();

        string typeName = GetDocStr(methodBase.DeclaringType, isParam: false, map);
        string methodName = ctor != null ? "#ctor" : methodBase.Name;
        string genericArgs = map.Methods.Count > 0 ? "``" + map.Methods.Count : "";
        string paramsStr = pars.Length > 0 ? "(" + pars.Select(x => GetDocStr(x.ParameterType, isParam: true, map)).Join(",") + ")" : "";
        string key = $"M:{typeName}.{methodName}{genericArgs}{paramsStr}";
        if (method != null && methodBase.Name is "op_Implicit" or "op_Explicit")
            key += "~" + GetDocStr(method.ReturnType, isParam: true, map);
        return key;

        Dictionary<string, int> GenericArgsToMap(Type[]? types) =>
            types?.Select((t, i) => (t.Name, Index: i)).ToDictionary(p => p.Name, p => p.Index) ?? new();
    }

    record Map(Dictionary<string, int> Types, Dictionary<string, int> Methods);
}

#><#+ } #>